# Backend Implementation Instructions

Use the following instructions to implement the backend for the project.

## Tech Stack

- Next.js
- Supabase Auth
- Supabase Database
- Supabase Storage

## Tables and Columns

### Users Table (auth.users - handled by Supabase Auth)
- id (uuid, primary key)
- email (string)
- created_at (timestamp)
- updated_at (timestamp)
- user_metadata (jsonb)
  - avatar_url
  - full_name
  - last_seen_at (timestamp)

### Emojis Table (public.emojis)
- id (uuid, primary key)
- created_at (timestamp)
- user_id (uuid, foreign key to auth.users.id)
- prompt (text, not null)
- storage_path (text, not null)
- likes_count (integer, default: 0)
- visibility (text, default: 'private', check: visibility in ('private', 'public'))

### User Likes Table (public.user_likes)
- id (uuid, primary key)
- created_at (timestamp)
- user_id (uuid, foreign key to auth.users.id)
- emoji_id (uuid, foreign key to emojis.id)
- unique constraint on (user_id, emoji_id)

## Storage Buckets

### Emojis Bucket (emojis)
- Purpose: Store generated emoji images
- Security Rules:
  - Upload: Authenticated users only
  - Read: Only owner can access their files
- File Structure: `emojis/{user_id}/{emoji_id}.png`
- Size Limit: 10MB per file
- Allowed Extensions: .png

#### Storage Bucket Policy
```
((bucket_id = 'emojis'::text) AND (auth.role() = 'authenticated'::text) AND ((storage.foldername(name))[1] = (auth.uid())::text))
```
This Supabase Storage policy (not SQL) ensures:
- User can only access their own folder through storage.foldername()
- User must be authenticated through auth.role()
- Operations are limited to 'emojis' bucket

Note: This is different from database RLS policies. Storage policies control file access, while RLS policies control database row access.

### Storage Access Approaches

There are two main approaches to handle emoji storage access:

1. **Authenticated Requests (Recommended)**
   ```typescript
   // Download and create blob URL
   const { data } = await supabase.storage
     .from('emojis')
     .download(storagePath);
   const blob = new Blob([data], { type: 'image/png' });
   const blobUrl = URL.createObjectURL(blob);
   ```
   - Pros:
     - Better security (requires authentication)
     - No URL exposure
     - Simpler implementation
     - Clear access control through RLS
   - Cons:
     - Slightly higher server load
     - Not ideal for very large files

2. **Signed URLs**
   ```typescript
   const { signedUrl } = await supabase.storage
     .from('emojis')
     .createSignedUrl(storagePath, 3600);
   ```
   - Pros:
     - Better performance for large files
     - Direct browser-to-storage access
   - Cons:
     - URLs can be shared/leaked
     - Temporary access only
     - No way to revoke access
     - Requires image domain configuration

# Requirements for user journey

## After user generates an emoji
- Store the emoji source file in the emojis bucket
- Store the emoji URL in the emojis table storage_path
- If visibility is set to private, the emoji should be visible only to the user who generated it
- If visibility is set to public, the emoji should be visible to all users

## Display all emojis generated by a user
- Get all emojis from the emojis table where the user_id is the current user's id
- Get the storage_path from the emojis table
- Get the URL from the storage_path
- Display the emojis in a grid

## Display all public emojis generated by all users
- Get all emojis from the emojis table where the visibility is public
- Get the storage_path from the emojis table
- Get the URL from the storage_path
- Display the emojis in a separate grid different from the user's own emojis

## Like an emoji
- Check if the user has already liked the emoji
- If the user has already liked the emoji, do nothing
- If the user has not already liked the emoji, insert a row into the user_likes table
- Increment the likes_count in the emojis table
